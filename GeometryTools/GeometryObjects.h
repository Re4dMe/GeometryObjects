#pragma once
#include <math.h>
#include <vector>
#include <stdexcept>
#include <format>
#include <sstream>

namespace GeometryObjects{

    template <typename T> 
    class Point {
        private:
            //Coordinates of a point, the dimension is inference by vector's size.
            std::vector<T> coordinates;
            
        public:
            Point() {};
        
            template <typename U>
            Point(std::vector<U> c) {
                setCoordinates(c);
            }

            template <typename U>
            void setCoordinates(std::vector<U> c) {
                this->coordinates.clear();
                for (auto value : c) {
                    this->coordinates.push_back(T(value));
                }
            }
            
            std::vector<T> getCoordinates() {
                return this->coordinates;
            }
            
            int dim() {
                return this->coordinates.size();
            }

            template <typename U>
            Point<T>& operator=(Point<U> v) {
                return setCoordinates(v.getCoordinates());
            }
    };

    template <typename T>
    class Vector {
        private:
            std::vector<T> components;

        public:
            Vector() {}

            template <typename U>
            Vector(std::vector<U> v) {
                for (auto value : v) {
                    components.push_back(T(value));
                }
            }
        
            template <typename U>
            Vector(Point<U> a, Point<U> b) {
                this->setComponentsByTwoPoints(a, b);
            }

            template <typename U>
            Vector crossProduct(Vector<U> b) {
                /*
                *   Calculate cross product of this Vector with another vector b
                *   Input: Another Vector b
                *   Return: the vector generated by cross product operation
                */
            
                //  check if dimensions of two vector are the same
                std::ostringstream oss;
                if (this->dim() != b.dim()) {
                    oss << "Two vectors have different dimension. The first is " << this->dim() << ". The second is " + b.dim();
                    throw std::invalid_argument(oss.str());
                }
                if (this->dim() != 3) {
                    oss << "CrossProduct operation for dimension != 3 is not implemented.";
                    throw std::invalid_argument(oss.str());
                }
                Vector normalVector;
                Vector v_A = *this;
                //TODO Generalize version to n-dim is needed
                normalVector.components.push_back(this->components[1] * b.components[2] - this->components[2] * b.components[1]);
                normalVector.components.push_back(-(this->components[0] * b.components[2] - this->components[2] * b.components[0]));
                normalVector.components.push_back(this->components[0] * b.components[1] - this->components[1] * b.components[0]);
                return normalVector;
            }

            template <typename U>
            T dot(Vector<U> b) {
                /*
                *   Calculate dot product of this Vector with another vector b
                *   Input: Another Vector b
                *   Return: the vector generated by dot product operation
                */

                double ret = 0;
                if (this->dim() != b.dim()) {
                    std::ostringstream oss;
                    oss << "Two vectors have different dimension. The first is " << this->dim() << ". The second is " + b.dim();
                    throw std::invalid_argument(oss.str());
                }
                for (int i = 0; i < this->dim(); i++) {
                    ret += this->components[i] * b.components[i];
                }
                return ret;
            }
        
            T norm(int d=2) {
                /*
                *   Calculate d-norm of the Vector
                *   Input: d indicate d-norm
                *   Return: the d-norm of the vector
                */

                T ret;
                for (auto value : components) {
                    ret += pow(value, d);
                }
                ret = pow(ret, 1/d);
                return ret;
            }

            Vector projectOnThisVector(Vector b) {
                /*
                *   Calculate projection vector of b project onto this vector
                */

                T n = this->dot(b) / this->dot(*this);
                //dot already check dimensions for these two vectors
                std::vector<T> projectedComponents;
                for (auto value : this->components) {
                    projectedComponents.push_back(n * value);
                }
                return Vector(projectedComponents);
            }
            
            std::vector<T> getComponents() {
                return this->components;
            }

            template <typename U>
            std::vector<T> setComponents(const Vector<U> v) {
                this->components.clear();
                for (auto value : v) {
                    this->components.push_back(T(value));
                }
                return this->components;
            }
            
            template <typename U>
            void setComponentsByTwoPoints(Point<U> a, Point<U> b) {
                /*
                *   Set components of this Vector by two points a, b
                *   Input: Two points a, b
                *   Return: The vector generated by: b - a
                */

                if (a.dim() != b.dim()) {
                    std::ostringstream oss;
                    oss << "Received two points with different dimension. The first is " << a.dim() << ". The second is " + b.dim();
                    throw std::invalid_argument(oss.str());
                }
                std::vector<double> newComponents;
                std::vector<double> aCoordinates = a.getCoordinates();
                std::vector<double> bCoordinates = b.getCoordinates();
                for (int i = 0; i < a.dim(); i++) {
                    newComponents.push_back(T(aCoordinates[i] - bCoordinates[i]));
                }
                components = newComponents;
            }

            int dim() {
                return components.size();
            }

            template <typename U>
            Vector<T>& operator=(const Vector<U> v) {
                return setComponents(v);
            }
    };
    
    template <typename T>
    class Plane {
    public:
        Point<T> startPoint;
        Vector<T> normalVector;
        
        template <typename U>
        Plane(Point<U> p, Vector<U> v1) {
            startPoint = p;
            normalVector = v1;
        }

        template <typename U>
        Plane(Point<U> a, Vector<U> v1, Vector<U> v2) {
            Vector<U> vp = v1.crossProduct(v2);
            /* 
            Normalize:
                vp = Vector(vp.x/vp.norm(), vp.y/vp.norm(), vp.z/vp.norm());
            */
            this->startPoint = a;
            this->normalVector = vp;
        }
    };

    template <typename T>
    class Line {
        public:
            Point<T> point;
            Vector<T> directionVector;
        
            template <typename U>
            Line(Point<U> a, Point<U> b) {
                this->point = a;
                this->directionVector = Vector<T>(a, b);
            }
            
            template <typename U>
            Point<T> intersectionPoint(Line<U> b) {
                /*
                *   Calculate point of intersection of two lines.    
                *   Input: Another Line b           
                *   Return: The point of intersection of these two lines.
                */
                Point p;
                Vector ab = Vector(this->point, b.directionVector);
                Vector c = this->directionVector.cp(b.B);
                double num = ab.cp(b.directionVector).dot(c);
                double dm = pow(c.norm(), 2);
                Vector r = Vector(num / dm * this->directionVector.x, num / dm * this->directionVector.y, num / dm * this->directionVector.z);
                Point rp = Point(this->point.x + r.x, this->point.y + r.y, this->point.z + r.z);
                return rp;
            }
    
            template <typename U>
            Point<T> projectPoint(Point<U> b) {
                /*
                *   Project point b onto this vector 
                */
                
                if (directionVector.dim() != b.dim()) {
                    std::ostringstream oss;
                    oss << "Received two points with different dimension. The first is " << a.dim() << ". The second is " + b.dim();
                    throw std::invalid_argument(oss.str());
                }

                Vector v2p = Vector(this->point, b);
                Vector p = this->directionVector.projectVector(v2p);
                return Point(this->point.x + p.x, this->point.y + p.y, this->point.z + p.z);
            }

            Point<T> getPoint() {
                return this->point;
            }
            Vector<T> getDirectionVector() {
                return this->directionVector;
            }
    };

}